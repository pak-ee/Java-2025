## Практика #1 — почему результаты разные

Перегрузка выбирается **на этапе компиляции** по **статическому типу** аргумента (и правилам преобразований: точное совпадение → примитивные преобразования → boxing/unboxing → расширение ссылочного типа). Реальный (runtime) тип объекта при перегрузке не учитывается — это важно отличать от *переопределения* (override), которое выбирается во время выполнения.

### (1) Цикл `for`

```java
Number[] num = { new Integer(1), 11, 1.11f, 11.11 };
for (Number n : num) {
    a.printNum(n);
}
```

- Массив объявлен как `Number[]`, значит **каждый элемент приводится к `Number`**:
  - `11` (тип `int`) → boxing в `Integer` → upcast к `Number`
  - `1.11f` (тип `float`) → boxing в `Float` → upcast к `Number`
  - `11.11` (тип `double`) → boxing в `Double` → upcast к `Number`
- Переменная цикла `n` имеет статический тип **`Number`**, поэтому компилятор видит вызов **только как** `printNum(Number)` и выбирает именно эту перегрузку для всех итераций.

Ожидаемо вывод будет вида:
```
Number=1
Number=11
Number=1.11
Number=11.11
```

### (2) Отдельные вызовы

```java
a.printNum(new Integer(1)); // аргумент типа Integer
a.printNum(11);             // аргумент типа int
a.printNum(1.11f);          // аргумент типа float
a.printNum(11.11);          // аргумент типа double
```

Здесь статические типы аргументов другие, поэтому выбираются более подходящие (более специфичные) перегрузки:

- `new Integer(1)` → точное совпадение с `printNum(Integer)`
- `11` (int) → точное совпадение с `printNum(int)` (это предпочтительнее, чем boxing в `Integer`)
- `1.11f` (float) → boxing в `Float` и вызов `printNum(Float)`
- `11.11` (double) → boxing в `Double`, но `printNum(Double)` нет, поэтому выбирается `printNum(Number)` (так как `Double` — это `Number`)

Примерный вывод:
```
Integer = 1
int = 11
Float = 1.1100
Number=11.11
```
