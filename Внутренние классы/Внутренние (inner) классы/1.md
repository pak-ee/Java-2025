# Практика #1 — спецификаторы доступа для внутренних классов

Внутренний (нестатический) класс может иметь любой спецификатор доступа: `public`, `protected`, *package-private* (без модификатора), `private`. В отличие от *top-level* классов, `private/protected` для внутренних классов разрешены.

Ниже — примеры и что они означают на практике.

## Пример

```java
// file: p1/Outer.java
package p1;

public class Outer {
    public class PublicInner {}

    protected class ProtectedInner {}

    class PackageInner {} // package-private

    private class PrivateInner {}

    // Внутри Outer можно пользоваться любыми внутренними классами
    public Object[] demoInsideOuter() {
        return new Object[] {
            new PublicInner(),
            new ProtectedInner(),
            new PackageInner(),
            new PrivateInner()
        };
    }
}
```

```java
// file: p1/SamePackage.java
package p1;

public class SamePackage {
    void demo() {
        Outer o = new Outer();
        Outer.PublicInner a = o.new PublicInner();      // OK: public
        Outer.ProtectedInner b = o.new ProtectedInner();// OK: protected (тот же пакет)
        Outer.PackageInner c = o.new PackageInner();    // OK: package-private (тот же пакет)
        // Outer.PrivateInner d = o.new PrivateInner(); // ERROR: private — видно только внутри Outer
    }
}
```

```java
// file: p2/OtherPackage.java
package p2;

import p1.Outer;

public class OtherPackage {
    void demo() {
        Outer o = new Outer();
        Outer.PublicInner a = o.new PublicInner(); // OK
        // Outer.ProtectedInner b = o.new ProtectedInner(); // ERROR: protected — не видно "просто так" из другого пакета
        // Outer.PackageInner c = o.new PackageInner();     // ERROR: package-private — не видно из другого пакета
    }
}
```

```java
// file: p2/SubOuter.java
package p2;

import p1.Outer;

public class SubOuter extends Outer {
    void demo() {
        // protected виден в подклассе даже в другом пакете,
        // но использовать его нужно через "this"/экземпляр подкласса:
        ProtectedInner x = this.new ProtectedInner(); // OK

        Outer other = new Outer();
        // Outer.ProtectedInner y = other.new ProtectedInner(); // чаще всего будет ERROR: доступ не через наследника
    }
}
```

## Итог по доступности (если создаём извне)

- `public`: доступен отовсюду, где виден `Outer`.
- `protected`: доступен в том же пакете, и в подклассах (даже в другом пакете) — при корректном доступе через наследника.
- *(без модификатора)*: доступен только внутри того же пакета.
- `private`: доступен только внутри внешнего класса `Outer`.

